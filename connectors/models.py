from django.db import models
from django.conf import settings
from polymorphic.models import PolymorphicModel
from connectors.utils import scrape_page, scrape_listing_page
import random


class Connector(PolymorphicModel):
    name = models.CharField(max_length=255, default="", help_text="Name of the connector")

    def __str__(self):
        return getattr(self.name, "name", f"Connector {self.pk}")


class ManualConnector(Connector):
    content_data = models.TextField(help_text="Content data for the manual connector")

    def __str__(self):
        return f"Manual Connector:  {self.name}"

    @property
    def get_content_data(self):
        return self.content_data

    @property
    def get_image_urls(self):
        return [f"{settings.DOMAIN}{image.image.url}" for image in self.images.all()]


class ManualConnectorImage(models.Model):
    manual_connector = models.ForeignKey(
        ManualConnector, related_name="images", on_delete=models.CASCADE, help_text="Manual connector that this image belongs to"
    )
    image = models.ImageField(upload_to="media_content_images/", help_text="Image file for the manual connector")

    def __str__(self):
        return f"Image for Media Content {self.manual_connector.pk}"


class ScraperConnector(Connector):
    base_url = models.URLField(help_text="Main page to scrape from")

    image_selector = models.CharField(
        max_length=255, help_text="CSS selector for the image element"
    )
    title_selector = models.CharField(
        max_length=255, help_text="CSS selector for the title element"
    )
    description_selector = models.CharField(
        max_length=255,
        blank=True,
        null=True,
        help_text="Optional CSS selector for description",
    )

    last_ran = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Scraper Connector: {self.name}"

    def persist_scraped_data(self, scraped_data):
        for data in scraped_data:
            scraped_item = ScrappedItem.objects.create(connector=self, scraped_data=data)
            return scraped_item.pk

    def get_scraped_data(self, for_social_media=None, for_channel=None):
        posted_items_pks = SocialPost.objects.filter(
            scrapped_item__connector=self,
            social_media=for_social_media,
            content_type=for_channel,
        ).values_list("scrapped_item__pk", flat=True)

        if self.scrapped_items.exists():
            items = list(self.scrapped_items.all().exclude(pk__in=posted_items_pks))
            if items:
                random_item = random.choice(items)
                return random_item.scraped_data, random_item.pk
            return None
        else:
            scraped_data = scrape_listing_page(
                self.base_url,
                self.image_selector,
                self.title_selector,
                self.description_selector,
            )
            scraped_item_pk = self.persist_scraped_data(scraped_data)
            return scraped_data, scraped_item_pk

    def get_content_data(self, for_social_media=None, for_channel=None):
        scraped_data, scraped_item_pk = self.get_scraped_data(for_social_media, for_channel)
        try:
            return f"{scraped_data.get('title')} - {scraped_data.get('description')}", scraped_item_pk
        except Exception as e:
            pass

    def get_image_urls(self, for_social_media=None, for_channel=None):
        scraped_data, _ = self.get_scraped_data(for_social_media, for_channel)
        try:
            return [scraped_data.get("images")]
        except Exception as e:
            pass


class ScrappedItem(models.Model):
    connector = models.ForeignKey(
        ScraperConnector, related_name="scrapped_items", on_delete=models.CASCADE, help_text="Connector that scraped this item"
    )
    scraped_data = models.JSONField(default={}, help_text="Data scraped from the connector's source")

    def __self__(self):
        return f"Scrapped Item {self.pk} from {self.connector.name}"


class SocialPost(models.Model):
    """
    A model representing a social media post.
    """

    scrapped_item = models.ForeignKey(
        ScrappedItem, related_name="social_posts", on_delete=models.CASCADE, help_text="The scrapped item that this post is based on"
    )
    ai_caption = models.TextField(default="", blank=True, help_text="Caption generated by AI, if applicable")
    caption = models.TextField(help_text="Caption for the post" )
    datetime = models.DateTimeField(auto_now_add=True, help_text="Date and time when the post was created")
    # post_identifier = models.CharField(blank=True, unique=True, max_length=300)
    social_media = models.CharField(
        max_length=50, choices=[("facebook", "Facebook"), ("instagram", "Instagram")], help_text="Social media platform for the post"
    )
    content_type = models.CharField(
        max_length=50, choices=[("post", "Post"), ("reel", "Reel")], default="post", help_text="Type of content for the post"
    )
    sound_track = models.CharField(max_length=255, blank=True, default="", help_text="Sound track used for the post, if applicable")

    def __str__(self):
        return f"Posted {self.scrapped_item} on {self.social_media} at {self.datetime}"
